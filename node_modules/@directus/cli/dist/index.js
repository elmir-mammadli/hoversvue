"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.command = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
// @ts-ignore
const amp = require("app-module-path");
amp.addPath(`${__dirname}/../node_modules`);
amp.addPath(`${process.cwd()}/node_modules`);
amp.addPath(process.cwd());
const gluegun_1 = require("gluegun");
const command_1 = require("./core/command");
const exceptions_1 = require("./core/exceptions");
var command_2 = require("./core/command");
Object.defineProperty(exports, "command", { enumerable: true, get: function () { return command_2.command; } });
const config = __importStar(require("./core/extensions/config"));
const output_1 = require("./core/output");
const options_1 = require("./core/options");
const events_1 = require("./core/events");
__exportStar(require("./command"), exports);
__exportStar(require("./config"), exports);
__exportStar(require("./events"), exports);
__exportStar(require("./help"), exports);
__exportStar(require("./options"), exports);
__exportStar(require("./output"), exports);
__exportStar(require("./toolbox"), exports);
function hasTsNode() {
    try {
        if (process[Symbol.for('ts-node.register.instance')]) {
            return true;
        }
    }
    catch {
        //
    }
    return false;
}
async function default_1(argv) {
    // create a runtime
    const brand = 'directusctl';
    const runtime = (0, gluegun_1.build)(brand)
        .exclude([
        'meta',
        'strings',
        'print',
        'filesystem',
        'semver',
        'system',
        'prompt',
        'http',
        'template',
        'patching',
        'package-manager',
    ])
        .create();
    const events = new events_1.Events();
    const options = new options_1.Options(events, process.argv);
    const output = new output_1.Output(options);
    let extensionsPath = process.env.EXTENSIONS_PATH ?? './extensions';
    if (config.project.data.experimental?.cli?.typescript?.enabled) {
        const project = config.project.data.experimental?.cli?.typescript.tsconfig || './tsconfig.json';
        if (fs.existsSync(project)) {
            if (!hasTsNode()) {
                if (!fs.existsSync('./node_modules/ts-node')) {
                    const error = new exceptions_1.CLIRuntimeError(`
						You're using experimental typescript support on the cli, but we couldn't find "ts-node" package installed.
						Please make sure to install it before proceeding.
					`);
                    await output.error(error);
                    return {
                        output,
                        error,
                    };
                }
                require('ts-node').register({
                    project: path.resolve(project),
                });
            }
        }
        else {
            throw new exceptions_1.CLIRuntimeError(`
				You're using experimental typescript support on the cli, but we couldn't find the typescript project file.
				Please make sure to configure it properly. The current value is "${project}"
			`);
        }
        extensionsPath = path.resolve(config.project.data.experimental?.cli?.typescript?.source || extensionsPath);
    }
    const loading = {
        state: false,
    };
    // Workaround stupid bug in gluegun
    // @ts-ignore
    const list = require('fs-jetpack/lib/list');
    const shimmer = require('shimmer');
    shimmer.wrap(list, 'sync', (original) => {
        return function (...args) {
            const result = original.apply(this, args);
            if (!loading.state) {
                return result;
            }
            const folder = args[0];
            const ts = hasTsNode();
            const files = result.filter((file) => {
                if (fs.statSync(path.join(folder, file)).isDirectory()) {
                    return true;
                }
                if (!ts) {
                    return file.endsWith('.js');
                }
                if (file.endsWith('.ts')) {
                    if (file.endsWith('.d.ts')) {
                        return false;
                    }
                    return true;
                }
                if (file.endsWith('.js')) {
                    // only allow .js if there's no matching .ts
                    return result.indexOf(`${file.slice(0, -3)}.ts`) < 0;
                }
                return false;
            });
            return files;
        };
    });
    loading.state = true;
    runtime.addDefaultPlugin(path.join(__dirname, 'cli'), {
        name: 'directus',
        hidden: false,
        commandFilePattern: hasTsNode() ? ['*.js', '*.ts'] : ['*.js'],
        extensionFilePattern: hasTsNode() ? ['*.js', '*.ts'] : ['*.js'],
    });
    runtime.addPlugin('./node_modules/directus/dist/cli/new', {
        name: 'directus-server',
        hidden: false,
        required: false,
    });
    const extensions = ['config', 'events', 'options', 'output', 'query', 'stdin', 'instances', 'help'];
    extensions.forEach((extension) => runtime.addExtension(extension, require(path.join(__dirname, `core/extensions/${extension}`))));
    if (config.project.data.experimental?.cli?.community_extensions) {
        // This isn't decided yet, please don't publish packages to npm until we have decided
        // if we'll have a naming pattern and what it's going to be.
        // TODO: Disabled to discourage usage/tests until final release and decision regarding this
        // runtime.addPlugins('./node_modules', { matching: 'directus-cli-*', hidden: false });
        // runtime.addPlugins('./node_modules', { matching: 'directus-*-cli', hidden: false });
        // runtime.addPlugins('./node_modules', { matching: '@directus/*-cli', hidden: false });
        // runtime.addPlugins('./node_modules', { matching: '@directus/cli-*', hidden: false });
    }
    const cliExtensionDir = path.resolve(extensionsPath, 'cli');
    if (fs.existsSync(cliExtensionDir)) {
        runtime.addPlugin(cliExtensionDir, {
            name: 'directus-project',
            hidden: false,
            required: false,
        });
    }
    loading.state = false;
    // add a default command first
    runtime.defaultCommand = (0, command_1.command)({
        disableHelp: true,
    }, async function ({ help, parameters: { array } }) {
        if (array && array.length) {
            let suggestion = [''];
            const suggestions = (await help.suggest(array)).filter(({ score }) => score >= 0.8);
            if (suggestions.length > 0) {
                if (suggestions[0].score >= 1) {
                    suggestion = [`\nDid you mean "${brand} ${suggestions[0]?.suggestion}"?`];
                }
                else {
                    suggestion = [
                        `\n\nDid you mean any of the following ones?\n`,
                        ...suggestions.map(({ suggestion }) => `- ${brand} ${suggestion}`),
                    ];
                }
            }
            throw new exceptions_1.CLIRuntimeError(`Unknown command: "${brand} ${array.join(' ')}"${suggestion.join('\n')}`);
        }
        await help.displayHelp();
    });
    const commandResult = {};
    try {
        const { result, output } = await runtime.run(argv);
        commandResult.help = result.help;
        commandResult.result = result.data;
        commandResult.error = result.error;
        commandResult.output = output;
    }
    catch {
        //
    }
    return commandResult;
}
exports.default = default_1;
