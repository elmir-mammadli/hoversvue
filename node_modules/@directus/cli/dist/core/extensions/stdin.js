"use strict";
/**
 * This should move to it's own class to be testable.
 * Had to rewrite due to last approach throwing randomly on linux machines.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeFeatures = exports.SupportedFormats = void 0;
const redent_1 = __importDefault(require("redent"));
const exceptions_1 = require("../exceptions");
const parsers_1 = require("../parsers");
exports.SupportedFormats = ['binary', 'json', 'stream', 'text', 'yaml'];
function normalizeFeatures(requested) {
    if (!requested) {
        return {};
    }
    const options = Object.keys(requested);
    const required = Object.entries(requested)
        .filter(([_, feature]) => !!feature.required)
        .map(([name]) => name);
    if (required.length > 1) {
        throw new exceptions_1.CLIRuntimeError(`Implementation error: can't require multiple stdin options (${required.join(', ')})`);
    }
    if (required.length > 0 && options.length > 1) {
        throw new exceptions_1.CLIRuntimeError(`Implementation error: can't have multiple stdin options if one is required`);
    }
    return Object.entries(requested)
        .map(([name, feature]) => {
        feature.description =
            feature.description ||
                `
					Used to pass content to the command. To understand how this works
					in this context, please check the command usage & documentation.

					# Examples

					## Load content from a file

					\`\`\`
					$ cat file | <command> --${name}=<format>
					\`\`\`
				`;
        feature.description = (0, redent_1.default)(feature.description);
        feature.exclusive = feature.exclusive || [];
        if (!Array.isArray(feature.exclusive)) {
            feature.exclusive = [feature.exclusive];
        }
        const exclusive = options.filter((opt) => opt != name).concat(...feature.exclusive);
        if (exclusive.length) {
            feature.description =
                feature.description +
                    `\n**This can't be used together with the following options**\n\n` +
                    exclusive.map((opt) => `- --${opt}`).join('\n');
        }
        let supported = feature.formats;
        if (!Array.isArray(supported)) {
            if (typeof supported != 'string') {
                throw new exceptions_1.CLIRuntimeError(`Implementation error: invalid ${name} stdin format type (${typeof supported})`);
            }
            supported = [supported];
        }
        supported.forEach((format) => {
            if (typeof format != 'string') {
                throw new exceptions_1.CLIRuntimeError(`Implementation error: invalid ${name} stdin format type (${typeof supported})`);
            }
            else if (exports.SupportedFormats.indexOf(format) < 0) {
                throw new exceptions_1.CLIRuntimeError(`Unsupported stdin format: ${format}`);
            }
        });
        feature.formats = supported;
        return {
            name,
            feature,
        };
    })
        .filter((format) => format.feature.formats.length > 0)
        .reduce((prev, curr) => Object.assign(prev, {
        [curr.name]: curr.feature,
    }), {});
}
exports.normalizeFeatures = normalizeFeatures;
async function readBuffer(stream) {
    const chunks = [];
    stream.on('data', (chunk) => chunks.push(chunk));
    return await new Promise((resolve, reject) => {
        stream.on('end', () => resolve(Buffer.concat(chunks)));
        stream.on('error', () => reject(new exceptions_1.CLIRuntimeError('Error reading stdin')));
        stream.on('timeout', () => reject(new exceptions_1.CLIRuntimeError('Timeout reading stdin')));
        stream.resume();
    });
}
exports.default = (toolbox) => {
    toolbox.stdin = undefined;
    toolbox.options.register((builder, command) => {
        const features = Object.entries(normalizeFeatures(command.settings?.features?.stdin));
        features.forEach(([name, feature]) => {
            if (feature.formats.length == 1) {
                builder = builder.option(name, {
                    type: 'boolean',
                    description: feature.description,
                    demandOption: feature.required,
                });
            }
            else {
                builder = builder.option(name, {
                    type: 'string',
                    choices: feature.formats,
                    description: feature.description,
                    demandOption: feature.required,
                });
            }
        });
        return builder;
    });
    toolbox.events.on('command.execute.before', async (command, options) => {
        const features = normalizeFeatures(command.settings?.features?.stdin);
        const found = Object.keys(features).filter((key) => key in options);
        const toFlags = (keys) => keys.map((k) => `--${k}`).join(', ');
        if (!found.length) {
            return; // No stdin options passed
        }
        else if (found.length > 1) {
            throw new exceptions_1.CLIRuntimeError(`These options are mutually exclusive: ${toFlags(found)}`);
        }
        const key = found[0];
        const feature = features[key];
        const conflicts = feature.exclusive.filter((key) => key in options);
        if (conflicts.length > 0) {
            throw new exceptions_1.CLIRuntimeError(`You can't use these options with --${key}: ${toFlags(conflicts)}`);
        }
        let requested = options[key];
        if (feature.formats.length == 1) {
            if (typeof requested !== 'boolean' || !requested) {
                throw new exceptions_1.CLIRuntimeError(`Unknown stdin format "${requested}"`);
            }
            requested = feature.formats[0];
        }
        else {
            if (feature.formats.indexOf(`${requested}`) < 0) {
                throw new exceptions_1.CLIRuntimeError(`Unsupported format ${requested} on --${key}`);
            }
        }
        if (!process.stdin.readable) {
            throw new exceptions_1.CLIRuntimeError('Unable to open stdin stream.');
        }
        if (requested === 'json') {
            toolbox.stdin = (0, parsers_1.parseJson)((await readBuffer(process.stdin)).toString());
        }
        else if (requested === 'yaml') {
            toolbox.stdin = (0, parsers_1.parseYaml)((await readBuffer(process.stdin)).toString());
        }
        else if (requested === 'text') {
            toolbox.stdin = (await readBuffer(process.stdin)).toString();
        }
        else if (requested === 'binary') {
            toolbox.stdin = await readBuffer(process.stdin);
        }
        else if (requested === 'stream') {
            toolbox.stdin = process.stdin;
        }
        else {
            throw new exceptions_1.CLIRuntimeError(`Unknown stdin format: ${requested}`);
        }
    });
};
