"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIBuilder = exports.palette = exports.DefaultTerminalWidth = exports.FullTerminalWidth = exports.DefaultIndentSize = void 0;
const chalk_1 = __importDefault(require("chalk"));
const yargs_1 = __importDefault(require("yargs"));
const marked_1 = require("marked");
const marked_terminal_1 = __importDefault(require("marked-terminal"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const format_title_1 = __importDefault(require("@directus/format-title"));
// @ts-ignore
const cliui_1 = __importDefault(require("cliui"));
const cli_table3_1 = __importDefault(require("cli-table3"));
const figlet_1 = __importDefault(require("figlet"));
const redent_1 = __importDefault(require("redent"));
const cli_highlight_1 = require("cli-highlight");
exports.DefaultIndentSize = 2;
exports.FullTerminalWidth = yargs_1.default.terminalWidth() - 2;
exports.DefaultTerminalWidth = Math.min(70, yargs_1.default.terminalWidth() - 2);
exports.palette = {
    header: chalk_1.default.bgWhite.black.bold,
    quote: chalk_1.default.gray,
};
const TableMinimalBorders = {
    top: '',
    'top-mid': '',
    'top-left': '',
    'top-right': '',
    bottom: '',
    'bottom-mid': '',
    'bottom-left': '',
    'bottom-right': '',
    left: '',
    'left-mid': '',
    mid: '',
    'mid-mid': '',
    right: '',
    'right-mid': '',
    middle: '',
};
const TableCompactBorders = {
    mid: '',
    'left-mid': '',
    'mid-mid': '',
    'right-mid': '',
};
const TableMarkdownBorders = {
    ...TableMinimalBorders,
    left: '|',
    right: '|',
    middle: '|',
};
class UIBuilder {
    constructor(indentSize = exports.DefaultIndentSize, terminalWidth, indentLevel) {
        this.lines = [];
        this.indentLevel = indentLevel ?? 0;
        this.indentSize = indentSize;
        this.terminalWidth = terminalWidth ?? exports.DefaultTerminalWidth;
        this.markdownRenderer = null;
        this.configure({
            indent: indentSize,
            width: terminalWidth,
        });
    }
    configure(opts) {
        this.indentSize = opts.indent ?? exports.DefaultIndentSize;
        this.terminalWidth = opts.width ?? exports.DefaultTerminalWidth;
        this.markdownRenderer = new marked_terminal_1.default({
            width: this.terminalWidth - this.indentLevel * this.indentSize - 8,
            reflowText: true,
            showSectionPrefix: false,
            tab: this.indentSize,
            codespan: (text) => chalk_1.default.reset.bgGray.white(`${text}`),
            blockquote: (text) => exports.palette.quote((0, strip_ansi_1.default)(text)
                .split('\n')
                .map((l) => `\xA0${l.trim()}`)
                .join('\n')),
        });
        this.markdownRenderer.code = function (code, lang) {
            code = (0, cli_highlight_1.highlight)(code, {
                language: lang || 'js',
                ignoreIllegals: true,
            });
            code = code
                .split('\n')
                .map((line) => `${chalk_1.default.gray('\xA0')}${line}`)
                .join('\n');
            return code + '\n\n';
        };
    }
    defaultTextOptions(options) {
        options = options ?? {};
        options.removeIndent = options.removeIndent ?? true;
        options.padding = options.padding ?? [0, 0, 0, 0];
        options.style = options.style ?? ((s) => chalk_1.default.reset(s));
        options.alignment = options.alignment ?? 'left';
        for (let i = 0; i < 4; i++) {
            if (i > options.padding.length - 1) {
                options.padding[i] = 0;
            }
        }
        return options;
    }
    makeLayout(text, options) {
        const ui = (0, cliui_1.default)({
            width: this.terminalWidth,
        });
        const opts = this.defaultTextOptions(options);
        opts.padding[3] += this.indentLevel * this.indentSize;
        ui.div({
            padding: opts.padding,
            text: opts.removeIndent ? (0, redent_1.default)(text) : text,
        });
        return opts.style(ui.toString());
    }
    async text(text, options) {
        this.lines.push(this.makeLayout(text, options));
    }
    async rows(data) {
        const ui = (0, cliui_1.default)({
            width: this.terminalWidth,
        });
        data.forEach((row) => {
            ui.div(...row.map((col) => {
                const opts = this.defaultTextOptions(col.options);
                opts.padding[3] += this.indentLevel * this.indentSize;
                return {
                    align: opts.alignment,
                    padding: opts.padding,
                    text: opts.style(opts.removeIndent ? (0, redent_1.default)(col.text) : col.text),
                };
            }));
        });
        this.lines.push(ui.toString());
    }
    async header(name, style) {
        style = style ?? exports.palette.header;
        this.lines.push(this.makeLayout(style(`\xA0${name.toUpperCase()}\xA0`)));
    }
    async table(values, options) {
        const opts = options || {};
        opts.style = opts.style || 'minimal';
        opts.headFormat = opts.headFormat || ((v) => chalk_1.default.reset.green.bold(v));
        opts.alignments = opts.alignments || values[0]?.map((_) => 'left') || [];
        opts.widths = opts.widths || values[0]?.map((_) => null) || [];
        opts.wrap = opts.wrap ?? true;
        opts.truncate = opts.truncate ?? true;
        if (opts.head) {
            opts.head = opts.head.map(opts.headFormat);
        }
        let table;
        switch (opts.style) {
            case 'compact':
                table = new cli_table3_1.default({
                    head: opts.head,
                    colAligns: opts.alignments,
                    colWidths: opts.widths,
                    chars: TableCompactBorders,
                    wordWrap: opts.wrap,
                    truncate: opts.truncate ? '…' : undefined,
                });
                break;
            case 'markdown':
                table = new cli_table3_1.default({
                    head: opts.head,
                    colAligns: opts.alignments,
                    colWidths: opts.widths,
                    chars: TableMarkdownBorders,
                    wordWrap: opts.wrap,
                    truncate: opts.truncate ? '…' : undefined,
                });
                break;
            case 'minimal':
            default:
                table = new cli_table3_1.default({
                    head: opts.head,
                    colAligns: opts.alignments,
                    colWidths: opts.widths,
                    chars: TableMinimalBorders,
                    wordWrap: opts.wrap,
                    truncate: opts.truncate ? '…' : undefined,
                });
                break;
        }
        if (table) {
            table.push(...values);
            await this.text(table.toString());
        }
    }
    async skip(lines = 1) {
        for (let i = 0; i < lines /*Math.max(lines, 1)*/; i++) {
            await this.line('');
        }
    }
    async line(value) {
        await this.text(value);
    }
    markdown(text) {
        return (0, marked_1.marked)((0, redent_1.default)(text), {
            baseUrl: 'https://docs.directus.io',
            renderer: this.markdownRenderer,
            sanitize: false,
        }).trim();
    }
    async figlet(text) {
        await this.text(figlet_1.default.textSync(text, 'Big'));
    }
    async section(name, wrapper, style) {
        await this.header(name, style);
        await this.skip();
        if (wrapper) {
            await this.wrap(wrapper);
            await this.skip();
        }
    }
    async wrap(build, verticalPadding) {
        this.indentLevel += 1;
        verticalPadding = verticalPadding ?? 0;
        await this.skip(verticalPadding);
        await build(this);
        await this.skip(verticalPadding);
        this.indentLevel -= 1;
    }
    async error(err, options) {
        options = options || {};
        options.stacktrace = options.stacktrace ?? false;
        options.title = options.title || 'Error';
        await this.skip();
        await this.header(options.title, chalk_1.default.bgRed.black);
        await this.skip();
        await this.wrap(async (builder) => {
            await builder.line(chalk_1.default.redBright(err.message));
        });
        if (!options.stacktrace) {
            await this.skip(2);
        }
        else {
            const stack = new UIBuilder(this.indentSize, exports.FullTerminalWidth, this.indentLevel);
            await stack.wrap((builder) => builder.line(chalk_1.default.grey(err.stack ?? 'No stacktrace available')), 1);
            await stack.skip(1);
            this.lines.push(await stack.get());
        }
    }
    async json(value, style = 'compact') {
        if (Array.isArray(value)) {
            this.lines.push(await this.jsonArray(value, style));
            return;
        }
        const fields = Object.keys(value).sort();
        const val = value;
        const ui = new UIBuilder(this.indentSize, exports.FullTerminalWidth, this.indentLevel);
        await ui.wrap(async (ui) => await ui.table(await Promise.all(fields.map(async (field) => {
            return [
                field,
                await this.jsonHighlight(val[field], {
                    highlight: true,
                    pretty: true,
                }),
            ];
        })), {
            wrap: true,
            head: ['Property', 'Value'],
            alignments: ['right', 'left'],
            headFormat: (v) => chalk_1.default.reset.bold((0, format_title_1.default)(v)),
            style,
        }));
        this.lines.push(await ui.get());
    }
    async jsonArray(values, style = 'compact') {
        const ui = new UIBuilder(this.indentSize, exports.FullTerminalWidth, this.indentLevel);
        if (values.length <= 0) {
            await ui.wrap((ui) => ui.table([], {
                style,
            }));
        }
        else {
            const fields = Object.keys(values[0]).sort();
            await ui.wrap(async (ui) => await ui.table(await Promise.all(values.map((row) => Promise.all(fields.map((field) => this.jsonHighlight(row[field], {
                highlight: true,
                pretty: true,
            }))))), {
                wrap: true,
                head: fields,
                headFormat: (v) => chalk_1.default.reset.bold((0, format_title_1.default)(v)),
                style,
            }));
        }
        return await ui.get();
    }
    async jsonHighlight(value, options) {
        let formatted = JSON.stringify(value, null, options?.pretty || options?.highlight ? 2 : 0) ?? 'undefined';
        if (options?.highlight) {
            formatted = (0, cli_highlight_1.highlight)(formatted, {
                ignoreIllegals: true,
                language: 'json',
                theme: {
                    ...cli_highlight_1.DEFAULT_THEME,
                    string: chalk_1.default.reset.rgb(234, 118, 116),
                },
            });
        }
        return formatted;
    }
    async get() {
        return this.lines.join('\n');
    }
    async clear() {
        this.lines = [];
    }
}
exports.UIBuilder = UIBuilder;
