"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Options = void 0;
const yargs_1 = __importDefault(require("yargs"));
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const exceptions_1 = require("./exceptions");
class Options {
    constructor(events, argv) {
        this._parser = (0, yargs_1.default)(argv).help(false).version(false);
        this._registrators = [];
        this._parsed = null;
        this._raw = (0, yargs_parser_1.default)(argv);
        events.on('command.options.register', (command) => {
            const cmd = command;
            const name = cmd.commandPath
                ?.concat(...[command.settings?.parameters ?? ''])
                .filter((p) => p != '')
                .join(' ');
            this._parser.fail((message, err) => {
                this._error = err || new exceptions_1.CLIRuntimeError(message);
            });
            this._parser.showHelpOnFail(false).exitProcess(false);
            this._parser.command(name ?? '$0', cmd.description ?? '', (builder) => {
                for (const registrator of this._registrators) {
                    registrator(builder, command, this._raw);
                }
                return this._parser;
            }, (values) => {
                this._parsed = values;
            });
            this._parser.argv;
        });
    }
    register(registrator) {
        this._registrators.push(registrator);
    }
    feature(name, registrator) {
        this._registrators.push((options, command) => {
            const { settings } = command;
            if (!settings) {
                return;
            }
            const { features } = settings;
            if (!features || !(name in features) || !features[name]) {
                return;
            }
            registrator(options, command, this._raw);
        });
    }
    failed() {
        return !!this._error;
    }
    error() {
        return this._error;
    }
    values() {
        return this._parsed || {};
    }
    list() {
        const freeParser = this._parser;
        const usage = freeParser.getUsageInstance();
        const descriptions = usage.getDescriptions();
        const keys = Object.keys(descriptions);
        const options = freeParser.getOptions();
        const positionalGroup = usage.getPositionalGroupName();
        const groups = freeParser.getGroups();
        return keys.map((key) => {
            const name = key;
            const description = descriptions[key];
            const value = options.default[key] ?? undefined;
            const required = key in options.demandedOptions;
            const choices = options.choices[key];
            let type = 'string';
            if (options.boolean.indexOf(key) >= 0) {
                type = 'boolean';
            }
            else if (options.number.indexOf(key) >= 0) {
                type = 'number';
            }
            let positional = false;
            if (positionalGroup in groups) {
                positional = groups[positionalGroup].indexOf(key) >= 0;
            }
            return {
                name,
                description,
                type,
                required,
                choices,
                positional,
                default: value,
            };
        });
    }
}
exports.Options = Options;
